<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>가계부 (Supabase · 월별 기록 업로드 · 최소 템플릿)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; }
    h1 { margin: 0 0 8px; }
    .muted { color:#666; font-size:12px; }
    .card { border:1px solid #e7e7e7; border-radius:16px; padding:14px; margin:12px 0; }
    input, select, button { padding:10px; border:1px solid #ccc; border-radius:12px; font-size:14px; }
    button { cursor:pointer; background:#f6f6f6; }
    button.primary { background:#111; color:#fff; border-color:#111; }
    .toolbar { display:flex; flex-wrap:wrap; gap:8px; align-items:center; justify-content:space-between; }
    .grid2 { display:grid; grid-template-columns:1fr 1fr; gap:10px; }
    .hidden { display:none !important; }
    .pill { display:inline-flex; padding:6px 10px; border:1px solid #e5e5e5; border-radius:999px; font-size:13px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>

  <!-- XLSX -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <script>
    // ✅ Supabase
    const SUPABASE_URL = "https://cqxpmfxwgrpdtxomxfiz.supabase.co";
    const SUPABASE_KEY = "sb_publishable_srN_e_EFhBbMEnPHSyu2Eg_03Mw37jS";

    const DEFAULT_LEDGER_NAME = "우리집";
    const SS_KEY = "ledger_session_v1";

    // ✅ 공통 컬럼이 생기는 기준 월(포함)
    const COMMON_START_MONTH = "2026-01";

    let session = null; // { access_token, refresh_token, user }
    let currentLedgerId = null;
    let cachedMembers = []; // active members

    const byId = (id) => document.getElementById(id);

    const todayISO = () => {
      const d = new Date();
      const z = new Date(d.getTime() - d.getTimezoneOffset()*60000);
      return z.toISOString().slice(0,10);
    };

    function setStatus(msg){ byId("status").textContent = msg || ""; }
    function setError(msg){ byId("error").textContent = msg || ""; }
    function show(el, yes){ el.classList.toggle("hidden", !yes); }

    function saveSession(s){
      session = s;
      if (s) localStorage.setItem(SS_KEY, JSON.stringify(s));
      else localStorage.removeItem(SS_KEY);
    }
    function loadSession(){
      const raw = localStorage.getItem(SS_KEY);
      if(!raw) return null;
      try { return JSON.parse(raw); } catch { return null; }
    }

    async function apiFetch(path, { method="GET", query=null, body=null, auth=true, preferReturn=true, extraHeaders=null } = {}){
      const url = new URL(SUPABASE_URL + path);
      if(query){
        for(const [k,v] of Object.entries(query)){
          if(v === undefined || v === null) continue;
          url.searchParams.set(k, v);
        }
      }

      const headers = { "apikey": SUPABASE_KEY };
      if(body) headers["Content-Type"] = "application/json";
      if(auth && session?.access_token) headers["Authorization"] = "Bearer " + session.access_token;

      if(preferReturn && (method==="POST" || method==="PATCH")){
        headers["Prefer"] = "return=representation";
      }
      if(extraHeaders){
        for(const [k,v] of Object.entries(extraHeaders)) headers[k] = v;
      }

      const res = await fetch(url.toString(), {
        method,
        headers,
        body: body ? JSON.stringify(body) : undefined
      });

      const text = await res.text();
      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch { data = text || null; }

      if(!res.ok){
        const msg = (data && typeof data === "object")
          ? (data.msg || data.message || data.error_description || JSON.stringify(data))
          : String(data || `HTTP ${res.status}`);
        throw new Error(msg);
      }
      return data;
    }

    // ---------- Auth (email+password) ----------
    async function fetchUser(){
      return await apiFetch("/auth/v1/user", { method:"GET", auth:true, preferReturn:false });
    }

    async function loginWithPassword(email, password){
      const data = await apiFetch("/auth/v1/token", {
        method: "POST",
        auth: false,
        query: { grant_type: "password" },
        body: { email, password },
        preferReturn: false
      });

      saveSession({ access_token: data.access_token, refresh_token: data.refresh_token, user: null });
      const user = await fetchUser();
      saveSession({ ...session, user });
    }

    async function logout(){
      saveSession(null);
    }

    // ---------- App ----------
    async function refreshUI(){
      const authed = !!(session?.access_token);

      show(byId("authCard"), !authed);
      show(byId("monthlyCard"), authed);

      byId("who").textContent = authed ? `로그인: ${session.user?.email || ""}` : "";
      byId("ledgerName").textContent = "";

      if(!authed){
        setStatus("로그인 상태가 아니야.");
        return;
      }

      if(!byId("monthPick").value) byId("monthPick").value = todayISO().slice(0,7);

      await ensureDefaultLedger();
      await loadMembers();

      setStatus("준비 완료!");
    }

    async function ensureDefaultLedger(){
      const ledgers = await apiFetch("/rest/v1/ledgers", {
        query: { select:"id,name,created_at", order:"created_at.asc" }
      });

      if(ledgers?.length){
        currentLedgerId = ledgers[0].id;
        byId("ledgerName").textContent = ledgers[0].name;
        return;
      }

      const createdArr = await apiFetch("/rest/v1/ledgers", {
        method:"POST",
        body: { name: DEFAULT_LEDGER_NAME, created_by: session.user.id }
      });
      const created = createdArr?.[0];
      if(!created?.id) throw new Error("장부 생성 실패");

      currentLedgerId = created.id;
      byId("ledgerName").textContent = DEFAULT_LEDGER_NAME;
    }

    async function loadMembers(){
      const members = await apiFetch("/rest/v1/members", {
        query: {
          select:"id,name,kind,is_active",
          ledger_id:`eq.${currentLedgerId}`,
          is_active:"eq.true",
          order:"kind.desc,name.asc"
        }
      });
      cachedMembers = members || [];
    }

    // =========================================
    // ✅ 월별 "기록" 템플릿 업/다운 (monthly_records)
    // =========================================

    // 기록 템플릿에 들어갈 카테고리 라인(최소)
    // ※ flow는 monthly_records.flow_type으로 저장됨
    const RECORD_ROWS = [
      // expense
      { flow:"expense", category:"식비", sub:"식재료", note:"" },
      { flow:"expense", category:"식비", sub:"외식", note:"" },
      { flow:"expense", category:"식비", sub:"배달", note:"" },
      { flow:"expense", category:"식비", sub:"중식", note:"" },
      { flow:"expense", category:"식비", sub:"카페/간식", note:"" },

      { flow:"expense", category:"소비 생활", sub:"쇼핑", note:"의류, 잡화, 가방, 신발, 화장품" },
      { flow:"expense", category:"소비 생활", sub:"미용", note:"미용실, 네일, 미용시술" },
      { flow:"expense", category:"소비 생활", sub:"구독", note:"넷플릭스, 유튜브프리미엄, 음악, 클라우드, 멤버십" },
      { flow:"expense", category:"소비 생활", sub:"생활편의", note:"생필품, 가전, 인테리어, 가구" },

      { flow:"expense", category:"문화여가", sub:"여행", note:"항공권, 숙박, 교통, 입장권" },
      { flow:"expense", category:"문화여가", sub:"취미", note:"" },
      { flow:"expense", category:"문화여가", sub:"도서", note:"" },

      { flow:"expense", category:"건강·관리", sub:"운동", note:"" },
      { flow:"expense", category:"건강·관리", sub:"병원", note:"" },
      { flow:"expense", category:"건강·관리", sub:"약/영양제", note:"" },

      { flow:"expense", category:"인간관계", sub:"선물", note:"" },
      { flow:"expense", category:"인간관계", sub:"경조사", note:"" },
      { flow:"expense", category:"인간관계", sub:"모임", note:"" },

      { flow:"expense", category:"예비/기타", sub:"예비비", note:"" },
      { flow:"expense", category:"예비/기타", sub:"기타", note:"" },

      { flow:"expense", category:"필수 생활", sub:"주거/관리비", note:"" },
      { flow:"expense", category:"필수 생활", sub:"통신", note:"" },
      { flow:"expense", category:"필수 생활", sub:"교통", note:"" },

      // saving
      { flow:"saving", category:"금융·저축", sub:"적금", note:"" },
      { flow:"saving", category:"금융·저축", sub:"투자", note:"" },
      { flow:"saving", category:"금융·저축", sub:"대출상환", note:"" },

      // income
      { flow:"income", category:"수입", sub:"급여", note:"" },
      { flow:"income", category:"수입", sub:"부수입", note:"" },
      { flow:"income", category:"수입", sub:"환급/기타", note:"" },
      { flow:"income", category:"수입", sub:"이자/배당", note:"" },
    ];

    function monthToDate(monthYYYYMM){
      return `${monthYYYYMM}-01`;
    }

    function hasCommonForMonth(monthYYYYMM){
      // 문자열 비교로 충분 (YYYY-MM 형태)
      return monthYYYYMM >= COMMON_START_MONTH;
    }

    function getMemberIdByName(name){
      const m = cachedMembers.find(x => x.name === name);
      return m ? m.id : null;
    }

    function parseNumberCell(v){
      if(v === null || v === undefined) return null;
      const s = String(v).replaceAll(",","").trim();
      if(s === "") return null;
      const n = Number(s);
      if(!Number.isFinite(n)) return NaN;
      return n;
    }

    async function downloadRecordTemplate(){
      const month = byId("monthPick").value;
      if(!month) throw new Error("월을 선택해줘");

      await loadMembers();

      const cols = hasCommonForMonth(month)
        ? ["돌프","천사","공통"]
        : ["돌프","천사"];

      // 필요한 멤버가 없으면 안내
      const missing = cols.filter(n => !getMemberIdByName(n));
      if(missing.length){
        throw new Error(`members에 ${missing.join(", ")} 가 없어. 먼저 멤버 추가해줘.`);
      }

      const aoa = [];
      aoa.push(["월", month, "", "", "", ""]);
      aoa.push(["대분류(B)", "소분류(C)", "설명(D)", ...cols]);

      for(const r of RECORD_ROWS){
        aoa.push([r.category, r.sub, r.note || "", ...cols.map(()=> "")]);
      }

      const wb = XLSX.utils.book_new();
      const ws = XLSX.utils.aoa_to_sheet(aoa);
      XLSX.utils.book_append_sheet(wb, ws, "기록");

      // meta sheet (업로드 안정화)
      const meta = XLSX.utils.aoa_to_sheet([
        ["month", month],
        ["ledger_id", currentLedgerId],
        ["common_start_month", COMMON_START_MONTH]
      ]);
      XLSX.utils.book_append_sheet(wb, meta, "_meta");

      XLSX.writeFile(wb, `기록_${month}.xlsx`);
    }

    async function uploadRecordFile(file){
      if(!file) return;

      setError("");
      setStatus("기록 엑셀 읽는 중...");

      const buf = await file.arrayBuffer();
      const wb = XLSX.read(buf, { type:"array", cellDates:true });

      const ws = wb.Sheets["기록"] || wb.Sheets[wb.SheetNames[0]];
      const metaWs = wb.Sheets["_meta"];

      // header 기반 JSON
      const rows = XLSX.utils.sheet_to_json(ws, { defval:"" });
      if(!rows.length) throw new Error("기록 시트에 데이터가 없어");

      // 월 결정: _meta > 화면 선택
      let month = byId("monthPick").value || "";
      if(metaWs){
        const meta = XLSX.utils.sheet_to_json(metaWs, { defval:"" });
        // _meta는 ["month", "2026-01"] 형태라 sheet_to_json 결과가 다르게 나올 수 있음
        // 그래서 그냥 A1/B1 직접 읽음이 더 안전하지만 여기선 간단히: 화면 월 우선 + 사용자가 맞게 선택한다고 가정
      }
      if(!/^\d{4}-\d{2}$/.test(month)) throw new Error("월 선택이 필요해");

      const monthDate = monthToDate(month);
      const cols = hasCommonForMonth(month)
        ? ["돌프","천사","공통"]
        : ["돌프","천사"];

      await loadMembers();

      // 멤버 매핑
      const memberMap = {};
      for(const c of cols){
        const id = getMemberIdByName(c);
        if(!id) throw new Error(`멤버 '${c}'가 members에 없어. 먼저 멤버 추가해줘.`);
        memberMap[c] = id;
      }

      const payload = [];
      let skippedBlankCells = 0;

      for(let i=0;i<rows.length;i++){
        const r = rows[i];

        const category = (r["대분류(B)"] ?? r["대분류"] ?? r["category"] ?? "").toString().trim();
        const subcategory = (r["소분류(C)"] ?? r["소분류"] ?? r["subcategory"] ?? "").toString().trim();
        const note = (r["설명(D)"] ?? r["설명"] ?? r["note"] ?? "").toString().trim();

        if(!category && !subcategory) continue;

        // flow_type: 사전에 정의된 RECORD_ROWS에 있으면 그 값, 없으면 expense
        const def = RECORD_ROWS.find(x => x.category===category && x.sub===subcategory);
        const flow_type = def ? def.flow : "expense";

        // ✅ 공란 스킵(기존 유지)
        for(const person of cols){
          const n = parseNumberCell(r[person]);
          if(n === null){
            skippedBlankCells++;
            continue; // 스킵 = 기존값 유지
          }
          if(Number.isNaN(n) || n < 0){
            throw new Error(`(${i+3}행 ${person}) 금액이 이상해: ${r[person]}`);
          }

          payload.push({
            ledger_id: currentLedgerId,
            month: monthDate,
            member_id: memberMap[person],
            flow_type,
            category,
            subcategory,
            note: note || null,
            amount: Math.floor(n),
            created_by: session.user.id
          });
        }

        // 업로드 파일에 공통 컬럼이 있어도, 월이 2026-01 이전이면 무시(요구사항)
        // (cols에 공통이 없으므로 자동으로 무시됨)
      }

      if(!payload.length){
        setStatus("");
        setError("업로드할 값이 없어(전부 공란이었음). 공란 업로드는 허용되지만 저장할 게 없음.");
        return;
      }

      setStatus(`DB 저장 중... (${payload.length}개 저장, 공란 ${skippedBlankCells}개 스킵)`);

      await apiFetch("/rest/v1/monthly_records", {
        method:"POST",
        query:{ on_conflict:"ledger_id,month,member_id,flow_type,category,subcategory" },
        body: payload,
        preferReturn:false,
        extraHeaders:{ "Prefer":"resolution=merge-duplicates" }
      });

      setStatus("월별 기록 업로드 완료!");
    }

    // ---------- start ----------
    window.addEventListener("DOMContentLoaded", async () => {
      try {
        const s = loadSession();
        if (s) session = s;

        if (session?.access_token && !session.user) {
          const user = await fetchUser();
          saveSession({ ...session, user });
        }

        byId("btnLogin").addEventListener("click", async () => {
          try{
            const email = (byId("email").value || "").trim();
            const password = (byId("password").value || "").trim();
            if(!email || !password) return setError("이메일/비번 입력해줘");

            setError("");
            setStatus("로그인 중...");
            await loginWithPassword(email, password);
            await refreshUI();
          }catch(e){
            setError(e?.message || String(e));
          }finally{
            setStatus("");
          }
        });

        byId("btnLogout").addEventListener("click", async () => {
          await logout();
          await refreshUI();
        });

        byId("btnRecordDownload").addEventListener("click", async () => {
          try{
            setError("");
            setStatus("템플릿 생성 중...");
            await downloadRecordTemplate();
          }catch(e){
            setError(e?.message || String(e));
          }finally{
            setStatus("");
          }
        });

        byId("recordFile").addEventListener("change", async (e) => {
          const file = e.target.files?.[0];
          if(!file) return;
          try{
            setError("");
            setStatus("업로드 중...");
            await uploadRecordFile(file);
          }catch(err){
            setError(err?.message || String(err));
          }finally{
            setStatus("");
            e.target.value = "";
          }
        });

        await refreshUI();
      } catch (e) {
        console.error(e);
        setError(e?.message || String(e));
      }
    });
  </script>
</head>

<body>
  <h1>가계부</h1>
  <div class="muted">
    월별 "기록" 템플릿 다운로드 → 입력 → 업로드 → <span class="mono">monthly_records</span>에 저장 (공란은 스킵=기존값 유지)
  </div>

  <div class="card">
    <div class="toolbar">
      <div id="who" class="muted"></div>
      <button id="btnLogout">로그아웃</button>
    </div>
    <div class="muted">현재 장부: <span id="ledgerName" class="mono"></span></div>
    <div id="status" class="muted"></div>
    <div id="error" class="muted" style="color:#b00020;"></div>
  </div>

  <div id="authCard" class="card hidden">
    <div class="toolbar" style="justify-content:flex-start;">
      <span class="pill">로그인</span>
      <input id="email" type="email" placeholder="이메일" style="min-width:260px;">
      <input id="password" type="password" placeholder="비밀번호" style="min-width:220px;">
      <button class="primary" id="btnLogin">로그인</button>
    </div>
    <div class="muted">Confirm email을 켰으면 인증 후 로그인해야 함.</div>
  </div>

  <div id="monthlyCard" class="card hidden">
    <div class="toolbar" style="justify-content:flex-start;">
      <span class="pill">월별 기록 업/다운</span>
      <label class="muted">월</label>
      <input id="monthPick" type="month" />
      <button class="primary" id="btnRecordDownload">기록 템플릿 다운로드</button>
      <label class="pill" style="cursor:pointer;">
        기록 업로드
        <input id="recordFile" type="file" accept=".xlsx,.xls" style="display:none;">
      </label>
    </div>
    <div class="muted">
      - 2026-01부터 <b>공통</b> 컬럼이 템플릿에 포함됨 (이전 달은 돌프/천사만)<br/>
      - B=대분류, C=소분류, D=설명, 금액 공란은 업로드해도 에러 없이 <b>스킵(기존 유지)</b>
    </div>
  </div>
</body>
</html>

